'''
This module contains utility functions for the main module.

author: Saurabh Bhardwaj
date: October 2023
'''

# import necessary libraries
import os
import sys
import pandas as pd
import numpy as np
import yaml
import dill
from src.logger import logging
from src.exception import MalwareException



def reduce_mem_usage(df: pd.DataFrame) -> pd.DataFrame:
    """
    Reduce the memory usage of the DataFrame.

    This function attempts to reduce the memory usage of a pandas DataFrame by
    downcasting numeric data types to the smallest possible type while preserving
    data integrity. It calculates the memory usage before and after the reduction
    to provide insights into memory savings.

    Args:
        df (pd.DataFrame): The DataFrame to optimize memory usage for.

    Returns:
        pd.DataFrame: The DataFrame with reduced memory usage.

    Raises:
        MalwareException: If there is an issue during the memory reduction process.

    Example:
        df = reduce_mem_usage(df)
    """
    numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']
    try:
        logging.info("Starting memory reduction of the DataFrame.")
        start_mem = df.memory_usage(deep=True).sum() / 1024**2
        for col in df.columns:
            col_type = df[col].dtypes
            if col_type in numerics:
                c_min = df[col].min()
                c_max = df[col].max()
                if str(col_type)[:3] == 'int':
                    if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:
                        df[col] = df[col].astype(np.int8)
                    elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:
                        df[col] = df[col].astype(np.int16)
                    elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:
                        df[col] = df[col].astype(np.int32)
                    elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:
                        df[col] = df[col].astype(np.int64)
                else:
                    if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:
                        df[col] = df[col].astype(np.float16)
                    elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:
                        df[col] = df[col].astype(np.float32)
                    else:
                        df[col] = df[col].astype(np.float64)
        end_mem = df.memory_usage(deep=True).sum() / 1024**2
        logging.info("Memory reduction is completed.")
        logging.info('Memory usage decreased to {:5.2f} Mb ({:.1f}% reduction)'.format(end_mem, 100 * (start_mem - end_mem) / start_mem))
        return df
    except Exception as e:
        raise MalwareException(e, sys) from e
    

def read_yaml_file(file_path: str) -> dict:
    """
    Read content from a YAML file and return it as a dictionary.

    This function reads the content from a YAML file specified by the file path
    and returns it as a dictionary.

    Args:
        file_path (str): The path to the YAML file to be read.

    Returns:
        dict: A dictionary containing the content from the YAML file.

    Raises:
        MalwareException: If there is an issue reading the YAML file.

    Example:
        data = read_yaml_file("config.yaml")
        print(data)
    """
    try:
        # Open the file for reading and load its content as a dictionary
        with open(file_path, "rb") as yaml_file:
            return yaml.safe_load(yaml_file)
    except Exception as e:
        # Raise a custom exception with context
        raise MalwareException(e, sys) from e


def write_yaml_file(file_path: str, content: object, replace: bool = False):
    """
    Write content to a YAML file.

    This function writes the provided content to a YAML file specified by the file path.

    Args:
        file_path (str): The path to the YAML file where the content will be written.
        content (object): The content to be written to the YAML file.
        replace (bool, optional): If True, replace the existing file if it exists. Default is False.

    Raises:
        MalwareException: If there is an issue writing the content to the YAML file.

    Example:
        data_to_write = {'key1': 'value1', 'key2': 'value2'}
        write_yaml_file("config.yaml", data_to_write, replace=True)
    """
    try:
        # Remove the existing file if 'replace' is set to True
        if replace and os.path.exists(file_path):
            os.remove(file_path)

        # Create the directory path if it does not exist
        os.makedirs(os.path.dirname(file_path), exist_ok=True)

        # Open the file for writing and write the content in YAML format
        with open(file_path, "a") as file:
            yaml.dump(content, file)
    except Exception as e:
        # Raise a custom exception with context
        raise MalwareException(e, sys) from e
    
def save_numpy_array_data(file_path: str, array: np.array):
    """
    Save a NumPy array to a file.

    This function saves a NumPy array to a file specified by the file path.

    Args:
        file_path (str): The path to the file where the NumPy array will be saved.
        array (np.array): The NumPy array to be saved.

    Raises:
        MalwareException: If there is an issue saving the NumPy array to the file.

    Example:
        data_to_save = np.array([1, 2, 3])
        save_numpy_array_data("data.npy", data_to_save)
    """
    try:
        # Create the directory path if it does not exist
        dir_path = os.path.dirname(file_path)
        os.makedirs(dir_path, exist_ok=True)

        # Open the file for writing in binary mode and save the NumPy array
        with open(file_path, "wb") as file_obj:
            np.save(file_obj, array)
    except Exception as e:
        # Raise a custom exception with context
        raise MalwareException(e, sys) from e


def load_numpy_array_data(file_path: str) -> np.array:
    """
    Load a NumPy array from a file.

    This function loads a NumPy array from a file specified by the file path.

    Args:
        file_path (str): The path to the file containing the NumPy array.

    Returns:
        np.array: The loaded NumPy array.

    Raises:
        MalwareException: If there is an issue loading the NumPy array from the file.

    Example:
        loaded_data = load_numpy_array_data("data.npy")
    """
    try:
        # Open the file for reading in binary mode and load the NumPy array
        with open(file_path, "rb") as file_obj:
            return np.load(file_obj, allow_pickle=True)
    except Exception as e:
        # Raise a custom exception with context
        raise MalwareException(e, sys) from e



def save_object(file_path: str, obj: object) -> None:
    """
    Save a serialized object to a file.

    This function serializes and saves an object to a file specified by the file path.

    Args:
        file_path (str): The path to the file where the object will be saved.
        obj (object): The object to be serialized and saved.

    Returns:
        None

    Raises:
        MalwareException: If there is an issue saving the object to the file.

    Example:
        data_to_save = [1, 2, 3, 4]
        save_object("data.pkl", data_to_save)
    """
    try:
        logging.info("Entered the save_object method")
        
        # Create the directory for the file if it doesn't exist
        os.makedirs(os.path.dirname(file_path), exist_ok=True)
        
        # Open the file for writing in binary mode and serialize the object
        with open(file_path, "wb") as file_obj:
            dill.dump(obj, file_obj)
        
        logging.info("Exited the save_object method")

    except Exception as e:
        # Raise a custom exception with context
        raise MalwareException(e, sys) from e



def load_object(file_path: str) -> object:
    """
    Load a serialized object from a file.

    This function loads a serialized object from a file specified by the file path.

    Args:
        file_path (str): The path to the file containing the serialized object.

    Returns:
        object: The deserialized object loaded from the file.

    Raises:
        MalwareException: If there is an issue loading the object from the file.

    Example:
        loaded_data = load_object("data.pkl")
    """
    try:
        # Check if the file exists
        if not os.path.exists(file_path):
            raise Exception(f"The file: {file_path} does not exist")

        # Open the file for reading in binary mode
        with open(file_path, "rb") as file_obj:
            # Load and return the deserialized object
            return dill.load(file_obj)

    except Exception as e:
        # Raise a custom exception with context
        raise MalwareException(e, sys) from e