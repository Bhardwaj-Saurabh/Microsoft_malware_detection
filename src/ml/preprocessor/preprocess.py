'''
This module contains the preprocessing pipeline for the data.

Author: Saurabh Bhardwaj
Date: Oct 2023
'''

# import libraries
import numpy as np
from sklearn.base import BaseEstimator, TransformerMixin
from sklearn.preprocessing import OrdinalEncoder
from src.logger import logging


def FeatureEngineeringTransformer(X):
    """
    Perform feature engineering on the input DataFrame X.

    Args:
        X (pd.DataFrame): The input DataFrame to which features will be added.

    Returns:
        pd.DataFrame: The DataFrame with engineered features.

    Raises:
        None
    """

    logging.info("Adding EngineVersion related features")

    # Engine Version
    X['EngineVersion_2'] = X['EngineVersion'].apply(
        lambda x: x.split('.')[2]).astype('category')
    X['EngineVersion_3'] = X['EngineVersion'].apply(
        lambda x: x.split('.')[3]).astype('category')

    logging.info("Adding Operating System Lab related features")
    # Operating System Lab
    # Replace NA values of 'OsBuildLab' column with '0.0.0.0-0'
    X['OsBuildLab'] = X['OsBuildLab'].fillna('0.0.0.0.0-0')

    X['OsBuildLab_0'] = X['OsBuildLab'].apply(
        lambda x: x.split('.')[0]).astype('category')
    X['OsBuildLab_1'] = X['OsBuildLab'].apply(
        lambda x: x.split('.')[1]).astype('category')
    X['OsBuildLab_2'] = X['OsBuildLab'].apply(
        lambda x: x.split('.')[2]).astype('category')
    X['OsBuildLab_3'] = X['OsBuildLab'].apply(
        lambda x: x.split('.')[3]).astype('category')

    logging.info("Adding Operating System Version related features")
    # Operating System Version
    X['Census_OSVersion_0'] = X['Census_OSVersion'].apply(
        lambda x: x.split('.')[0]).astype('category')
    X['Census_OSVersion_1'] = X['Census_OSVersion'].apply(
        lambda x: x.split('.')[1]).astype('category')
    X['Census_OSVersion_2'] = X['Census_OSVersion'].apply(
        lambda x: x.split('.')[2]).astype('category')
    X['Census_OSVersion_3'] = X['Census_OSVersion'].apply(
        lambda x: x.split('.')[3]).astype('category')

    logging.info("Adding Storage related features")
    # Storage
    X['primary_drive_c_ratio'] = X['Census_SystemVolumeTotalCapacity'] / \
        X['Census_PrimaryDiskTotalCapacity']
    X['non_primary_drive_MB'] = X['Census_PrimaryDiskTotalCapacity'] - \
        X['Census_SystemVolumeTotalCapacity']

    logging.info("Adding Aspect Ratio related features")
    # Aspect Ratio
    X['aspect_ratio'] = X['Census_InternalPrimaryDisplayResolutionHorizontal'] / \
        X['Census_InternalPrimaryDisplayResolutionVertical']

    logging.info("Adding DPI related features")
    # DPI
    X['dpi'] = ((X['Census_InternalPrimaryDisplayResolutionHorizontal']**2 +
                X['Census_InternalPrimaryDisplayResolutionVertical']**2)**.5) / (X['Census_InternalPrimaryDiagonalDisplaySizeInInches'])

    logging.info("Adding MP related features")
    # MP
    X['MegaPixels'] = (X['Census_InternalPrimaryDisplayResolutionHorizontal']
                       * X['Census_InternalPrimaryDisplayResolutionVertical']) / 1e6

    logging.info("Adding Screen Area related features")
    # Screen Area
    X['Screen_Area'] = (X['aspect_ratio'] * (
        X['Census_InternalPrimaryDiagonalDisplaySizeInInches']**2)) / (X['aspect_ratio']**2 + 1)

    logging.info("Adding RAM per processor related features")
    # RAM per processor
    X['ram_per_processor'] = X['Census_TotalPhysicalRAM'] / \
        X['Census_ProcessorCoreCount']

    logging.info("Adding Arbitrary features")
    # Arbitrary features
    X['new_num_0'] = X['Census_InternalPrimaryDiagonalDisplaySizeInInches'] / \
        X['Census_ProcessorCoreCount']
    X['new_num_1'] = X['Census_ProcessorCoreCount'] * \
        X['Census_InternalPrimaryDiagonalDisplaySizeInInches']

    logging.info("All Engineered features have been added.")
    return X


class OrdinalEncoderTransformer(BaseEstimator, TransformerMixin):
    """
    Custom transformer for encoding ordinal categorical variables using OrdinalEncoder.

    Args:
        variables (list or None): A list of column names to encode.
        If None, all columns will be encoded.
        unknown_value (int, optional): The value used for encoding
        unknown categories. Defaults to -100.

    Attributes:
        variables (list or None): A list of column names to encode.
        unknown_value (int): The value used for encoding unknown categories.
        encoder (OrdinalEncoder): The OrdinalEncoder instance for encoding.

    Methods:
        fit(X, y=None): Fit the encoder to the data.
        transform(X): Transform the data by encoding ordinal variables.
    """

    def __init__(self, variables=None, unknown_value=-100):
        """
        Initialize the OrdinalEncoderTransformer.

        Args:
            variables (list or None): A list of column names to encode.
            If None, all columns will be encoded.
            unknown_value (int, optional): The value used for encoding
            unknown categories. Defaults to -100.
        """
        self.variables = variables
        self.unknown_value = unknown_value
        self.encoder = OrdinalEncoder(
            handle_unknown='use_encoded_value',
            dtype='int32',
            unknown_value=unknown_value
        )

    def fit(self, X, y=None):
        """
        Fit the encoder to the data.

        Args:
            X (pd.DataFrame): The input data.
            y (pd.Series, optional): The target data. Default is None.

        Returns:
            self: The fitted transformer instance.
        """
        self.encoder.fit(X[self.variables], y)
        return self

    def transform(self, X):
        """
        Transform the data by encoding ordinal variables.

        Args:
            X (pd.DataFrame): The input data to be transformed.

        Returns:
            pd.DataFrame: The transformed data with encoded ordinal variables.
        """
        X_encoded = X.copy()
        X_encoded[self.variables] = self.encoder.transform(X[self.variables])
        maximum_values = X_encoded.max(axis=0)
        X_encoded = np.where(X_encoded == self.unknown_value,
                             maximum_values, X_encoded)
        return X_encoded
