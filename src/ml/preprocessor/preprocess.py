'''
This module contains the preprocessing pipeline for the data.

Author: Saurabh Bhardwaj
Date: Oct 2023
'''

# import libraries
import numpy as np
from src.logger import logging
from sklearn.base import BaseEstimator, TransformerMixin
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import TargetEncoder, OrdinalEncoder


class FrequencyEncodingTransformer(BaseEstimator, TransformerMixin):
    """
    A transformer for frequency encoding categorical variables in a DataFrame.
    """

    def __init__(self, variables):
        """
        Initializes a FrequencyEncodingTransformer instance.
        """
        self.variables = variables

    def fit(self, X, y):
        """
        Fits the transformer to the provided data. No specific fitting is needed for frequency encoding.
        """
        return self

    def transform(self, X):
        """
        Transforms the input DataFrame by applying frequency encoding to the specified variables.

        Args:
            X (pd.DataFrame): The input data to be transformed.

        Returns:
            pd.DataFrame: The transformed DataFrame with frequency-encoded variables.
        """
        for variable in self.variables:
            X[variable] = X[variable].astype('category')
            fq = X.groupby(variable).size() / len(X)
            X["{}".format(variable)] = X[variable].map(fq)
        return X


def FeatureEngineeringTransformer(X):
    """
    Perform feature engineering on the input DataFrame X.

    Args:
        X (pd.DataFrame): The input DataFrame to which features will be added.

    Returns:
        pd.DataFrame: The DataFrame with engineered features.

    Raises:
        None
    """

    logging.info("Adding EngineVersion related features")

    # Engine Version
    X['EngineVersion_2'] = X['EngineVersion'].apply(lambda x: x.split('.')[2]).astype('category')
    X['EngineVersion_3'] = X['EngineVersion'].apply(lambda x: x.split('.')[3]).astype('category')


    logging.info("Adding Operating System Lab related features")
    # Operating System Lab
    # Replace NA values of 'OsBuildLab' column with '0.0.0.0-0'
    X['OsBuildLab'] = X['OsBuildLab'].fillna('0.0.0.0.0-0')

    X['OsBuildLab_0'] = X['OsBuildLab'].apply(lambda x: x.split('.')[0]).astype('category')
    X['OsBuildLab_1'] = X['OsBuildLab'].apply(lambda x: x.split('.')[1]).astype('category')
    X['OsBuildLab_2'] = X['OsBuildLab'].apply(lambda x: x.split('.')[2]).astype('category')
    X['OsBuildLab_3'] = X['OsBuildLab'].apply(lambda x: x.split('.')[3]).astype('category')

    logging.info("Adding Operating System Version related features")
    # Operating System Version
    X['Census_OSVersion_0'] = X['Census_OSVersion'].apply(lambda x: x.split('.')[0]).astype('category')
    X['Census_OSVersion_1'] = X['Census_OSVersion'].apply(lambda x: x.split('.')[1]).astype('category')
    X['Census_OSVersion_2'] = X['Census_OSVersion'].apply(lambda x: x.split('.')[2]).astype('category')
    X['Census_OSVersion_3'] = X['Census_OSVersion'].apply(lambda x: x.split('.')[3]).astype('category')

    logging.info("Adding Storage related features")
    # Storage 
    X['primary_drive_c_ratio'] = X['Census_SystemVolumeTotalCapacity'] / X['Census_PrimaryDiskTotalCapacity']
    X['non_primary_drive_MB'] = X['Census_PrimaryDiskTotalCapacity'] - X['Census_SystemVolumeTotalCapacity']

    logging.info("Adding Aspect Ratio related features")
    # Aspect Ratio 
    X['aspect_ratio'] = X['Census_InternalPrimaryDisplayResolutionHorizontal'] / X['Census_InternalPrimaryDisplayResolutionVertical']

    logging.info("Adding DPI related features")
    # DPI
    X['dpi'] = ((X['Census_InternalPrimaryDisplayResolutionHorizontal']**2 + X['Census_InternalPrimaryDisplayResolutionVertical']**2)**.5) / (X['Census_InternalPrimaryDiagonalDisplaySizeInInches'])

    logging.info("Adding MP related features")
    # MP
    X['MegaPixels'] = (X['Census_InternalPrimaryDisplayResolutionHorizontal'] * X['Census_InternalPrimaryDisplayResolutionVertical']) / 1e6

    logging.info("Adding Screen Area related features")
    # Screen Area
    X['Screen_Area'] = (X['aspect_ratio'] * (X['Census_InternalPrimaryDiagonalDisplaySizeInInches']**2)) / (X['aspect_ratio']**2 + 1)

    logging.info("Adding RAM per processor related features")
    # RAM per processor
    X['ram_per_processor'] = X['Census_TotalPhysicalRAM'] / X['Census_ProcessorCoreCount']

    logging.info("Adding Arbitrary features")
    # Arbitrary features
    X['new_num_0'] = X['Census_InternalPrimaryDiagonalDisplaySizeInInches'] / X['Census_ProcessorCoreCount']
    X['new_num_1'] = X['Census_ProcessorCoreCount'] * X['Census_InternalPrimaryDiagonalDisplaySizeInInches']

    logging.info("All Engineered features have been added.")
    return X
        

class MissingValueTreatmentTransformer(BaseEstimator, TransformerMixin):
    """
    A transformer for handling missing values in a DataFrame.
    It drops columns with a high percentage of missing values and removes rows with any missing values.
    """

    def __init__(self, threshold=20):
        """
        Initializes a MissingValueTreatmentTransformer instance.

        Args:
            threshold (int): The threshold percentage above which columns are dropped.
            
        Returns:
            MissingValueTreatmentTransformer: The initialized instance.
        """
        self.threshold = threshold

    def fit(self, X, y):
        """
        Fits the transformer to the provided data. No specific fitting is needed for missing value treatment.
        """
        return self

    def transform(self, X):
        """
        Transforms the input DataFrame by handling missing values.
        It drops columns with missing values exceeding the threshold and removes rows with any missing values.

        Args:
            X (pd.DataFrame): The input data to be transformed.

        Returns:
            pd.DataFrame: The transformed DataFrame with missing values treated.
        """
        X = X.copy()
        for col in X.columns:
            missing_value_percent = X[col].isnull().sum() * 100 / X.shape[0]
            if missing_value_percent >= self.threshold:
                X.drop(col, axis=1, inplace=True)
            else:
                X = X[X[col].notna()]
        return X

    
class LabelEncoderTransformer(BaseEstimator, TransformerMixin):
    """
    A transformer for label encoding categorical columns in a DataFrame.
    It encodes categorical columns into numerical labels using sklearn's LabelEncoder.

    Args:
        categorical_columns (list): A list of column names to be label encoded.
    """

    def __init__(self, categorical_columns=None):
        self.categorical_columns = categorical_columns
        self.label_encoders = {}

    def fit(self, X, y):
        """
        Fits the transformer to the provided data by creating label encoders for the specified columns.
        """
        for col in self.categorical_columns:
            X[col] = X[col].astype('category')
            le = LabelEncoder()
            le.fit(X[col])
            self.label_encoders[col] = le
        return self

    def transform(self, X):
        """
        Transforms the input DataFrame by applying label encoding to the specified columns.

        Args:
            X (pd.DataFrame): The input data to be transformed.

        Returns:
            pd.DataFrame: The transformed DataFrame with label encoded columns.
        """
        X_encoded = X.copy()
        for col in self.categorical_columns:
            le = self.label_encoders[col]
            X_encoded[col] = le.transform(X[col])
        return X_encoded
    
class TargetEncoderTransformer(BaseEstimator, TransformerMixin):
    def __init__(self, variables):
        self.variables = variables

    def fit(self, X, y=None):
        self.encoder = TargetEncoder()
        self.encoder.fit(X[self.variables], y)
        return self

    def transform(self, X):
        X_encoded = X.copy()
        X_encoded[self.variables] = self.encoder.transform(X[self.variables])
        return X_encoded
    
class OrdinalEncoderTransformer(BaseEstimator, TransformerMixin):
    def __init__(self, variables=None, unknown_value = -100):
        self.variables = variables
        self.unknown_value = unknown_value
        self.encoder = OrdinalEncoder(handle_unknown = 'use_encoded_value', 
                                      dtype = 'int32', unknown_value = unknown_value)

    def fit(self, X, y=None):
        self.encoder.fit(X[self.variables], y)
        return self

    def transform(self, X):
        X_encoded = X.copy()
        X_encoded[self.variables] = self.encoder.transform(X[self.variables])
        maximum_values = X_encoded.max(axis = 0)
        X_encoded = np.where(X_encoded == self.unknown_value, maximum_values, X_encoded)
        return X_encoded